# docker的底层主要有这三部分来实现
1. chroot 用于设置根目录，在进程内独立的文件系统
2. namespace 用于隔离进程
3. cgroup 隔离用户组的一些状态

## chroot 
chroot是linux的一个命令，一般会在装系统的时候，或者开机启动系统的时候肯定会调用一下chroot把 ‘/’设置好，docker里面 启动一个容器的时候，也会起这样一
个独立的文件系统，这个一般是docker基础镜像，里面有基本的linux的那些目录和文件

## docker文件系统的分层和隔离
docker的文件系统是有个分层的概念，它的最底层，是你的镜像，然后在启动时候镜像的时候，它会把这个基础镜像当作lowwer层，然后在他之上还会有个upper层，
这个lowwer和upper会组成一个merged整个一个抽象的文件夹，这个upper和lowwer都可以由多个层组成，然后抽象出来的这个文件夹就是docker启动之后变成的容器
里面看到的那些文件，当我们访问的时候，会先从最上层找，如果找不到就会继续往下层找，最底层就是那个lowwer基础镜像里面的东西;当发生写操作的时候，只会写在
upper最外层，这样就是节省了空间不至于每次启动一个容器都是copy一个基础镜像里面的东西，类似于网吧无盘系统（网吧加载系统大部分是从网线加载过来的）

## namespace
这个主要用于隔离进程的，我们通常进入启动的容器里面的看到的只有这个容器启动的那些程序的进程可以看到，那就是docker做了进程隔离;docker启动之后其实是一个
进程，只是docker本生启动这个镜像的时候，不仅重新chroot了，而且还在拉起的这个docker进程的时候给传递了一些参数，这些参数告诉了linux启动的进程能看到
什么，不能看到什么，因为这些参数，我们不能在docker 容器空查看到系统的一些进程，就算kill 进程的id，docker也屏蔽了让你找不到。这个传递的参数里面包括
进程相关的，还有网络相关的，等等

## cgroup
这个没啥意思，就是类似于linux的组，那些用户能用，那些用户没有什么权限类似的东西

### 其他
1. 我们自己写的这个docker是简单的，如果打了reboot也是会整个机器重启，，目测原docker里面限制了reboot或者重写了reboot
2. chroot的时候，会mount -t type;这个type是指文件系统比如overlays 还是什么ntfs
3. 隔离进程还有用到个proc 和sys，这两个linux遗留下来的东西，不是文件也不是文件夹，什么都不是，也不报错，那是用来和linux内核通信的东西
4. linux系统在安装的时候，内核就是被单独的编译成了ko模块文件，启动时候加载，这也是为啥我的ubuntu可以动态的换内核的原因
5. 我们自己写的docker就是调用了那些个命令行里面的挂载和proc的东西
